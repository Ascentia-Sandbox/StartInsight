"""Export Service - Phase 5.3.

Generates exportable formats for insights and research analyses:
- PDF reports
- CSV data exports
- JSON API exports
"""

import csv
import io
import json
import logging
from datetime import datetime
from enum import Enum
from typing import Any

from app.core.config import settings

logger = logging.getLogger(__name__)


# ============================================================
# Export Format Enum
# ============================================================


class ExportFormat(str, Enum):
    """Supported export formats."""

    PDF = "pdf"
    CSV = "csv"
    JSON = "json"


# ============================================================
# PDF Generation (using simple HTML-to-PDF approach)
# ============================================================


def generate_pdf_content(
    title: str,
    sections: list[dict[str, Any]],
    metadata: dict[str, Any] | None = None,
) -> str:
    """
    Generate HTML content that can be converted to PDF.

    For production, this HTML would be rendered using a library like
    weasyprint, pdfkit, or a headless browser service.

    Args:
        title: Report title
        sections: List of sections with 'heading' and 'content'
        metadata: Optional metadata (date, author, etc.)

    Returns:
        str: HTML content formatted for PDF conversion
    """
    meta = metadata or {}
    generated_at = meta.get("generated_at", datetime.now().strftime("%Y-%m-%d %H:%M"))
    author = meta.get("author", "StartInsight")

    sections_html = ""
    for section in sections:
        heading = section.get("heading", "")
        content = section.get("content", "")

        if isinstance(content, list):
            content_html = "<ul>" + "".join(f"<li>{item}</li>" for item in content) + "</ul>"
        elif isinstance(content, dict):
            content_html = "<dl>"
            for key, val in content.items():
                content_html += f"<dt><strong>{key}</strong></dt><dd>{val}</dd>"
            content_html += "</dl>"
        else:
            content_html = f"<p>{content}</p>"

        sections_html += f"""
        <section class="section">
            <h2>{heading}</h2>
            {content_html}
        </section>
        """

    html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{title}</title>
    <style>
        @page {{
            size: A4;
            margin: 2cm;
        }}
        body {{
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            color: #1f2937;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }}
        .header {{
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }}
        .header h1 {{
            color: #3b82f6;
            margin-bottom: 10px;
        }}
        .meta {{
            color: #6b7280;
            font-size: 0.9em;
        }}
        .section {{
            margin-bottom: 30px;
            page-break-inside: avoid;
        }}
        .section h2 {{
            color: #1f2937;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 8px;
        }}
        .score-grid {{
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }}
        .score-item {{
            background: #f3f4f6;
            padding: 12px;
            border-radius: 8px;
        }}
        .score-value {{
            font-size: 1.5em;
            font-weight: bold;
            color: #3b82f6;
        }}
        ul, ol {{
            padding-left: 20px;
        }}
        li {{
            margin-bottom: 8px;
        }}
        dl {{
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 10px;
        }}
        dt {{
            color: #6b7280;
        }}
        .footer {{
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e5e7eb;
            text-align: center;
            color: #6b7280;
            font-size: 0.8em;
        }}
    </style>
</head>
<body>
    <header class="header">
        <h1>{title}</h1>
        <p class="meta">Generated on {generated_at} by {author}</p>
    </header>

    <main>
        {sections_html}
    </main>

    <footer class="footer">
        <p>Generated by StartInsight | AI-Powered Business Intelligence</p>
        <p>{settings.app_url}</p>
    </footer>
</body>
</html>"""

    return html


# ============================================================
# Insight Export Functions
# ============================================================


def export_insight_pdf(insight: dict[str, Any]) -> str:
    """
    Generate PDF HTML content for a single insight.

    Args:
        insight: Insight data dictionary

    Returns:
        str: HTML content for PDF conversion
    """
    sections = [
        {
            "heading": "Problem Statement",
            "content": insight.get("problem_statement", "N/A"),
        },
        {
            "heading": "Proposed Solution",
            "content": insight.get("proposed_solution", "N/A"),
        },
        {
            "heading": "Market Size",
            "content": insight.get("market_size_estimate", "N/A"),
        },
    ]

    # Add scores if available
    if "opportunity_score" in insight:
        scores = {
            "Opportunity Score": f"{insight.get('opportunity_score', 0)}/10",
            "Problem Score": f"{insight.get('problem_score', 0)}/10",
            "Feasibility Score": f"{insight.get('feasibility_score', 0)}/10",
            "Why Now Score": f"{insight.get('why_now_score', 0)}/10",
            "Revenue Potential": insight.get("revenue_potential", "N/A"),
            "Execution Difficulty": f"{insight.get('execution_difficulty', 0)}/10",
            "Go-to-Market Score": f"{insight.get('go_to_market_score', 0)}/10",
            "Founder Fit Score": f"{insight.get('founder_fit_score', 0)}/10",
        }
        sections.append({"heading": "8-Dimension Scoring", "content": scores})

    # Add competitors if available
    competitors = insight.get("competitors", [])
    if competitors:
        competitor_list = [
            f"{c.get('name', 'Unknown')} - {c.get('weakness', 'N/A')}"
            for c in competitors
        ]
        sections.append({"heading": "Competitor Analysis", "content": competitor_list})

    title = insight.get("problem_statement", "Insight Report")[:50]

    return generate_pdf_content(
        title=f"Insight Report: {title}",
        sections=sections,
        metadata={
            "generated_at": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "insight_id": insight.get("id", "N/A"),
        },
    )


def export_insight_csv(insights: list[dict[str, Any]]) -> str:
    """
    Generate CSV content for multiple insights.

    Args:
        insights: List of insight dictionaries

    Returns:
        str: CSV content as string
    """
    output = io.StringIO()

    # Define CSV columns
    fieldnames = [
        "id",
        "problem_statement",
        "proposed_solution",
        "market_size_estimate",
        "relevance_score",
        "opportunity_score",
        "problem_score",
        "feasibility_score",
        "why_now_score",
        "revenue_potential",
        "execution_difficulty",
        "go_to_market_score",
        "founder_fit_score",
        "source",
        "created_at",
    ]

    writer = csv.DictWriter(output, fieldnames=fieldnames, extrasaction="ignore")
    writer.writeheader()

    for insight in insights:
        # Flatten nested data
        row = {
            "id": str(insight.get("id", "")),
            "problem_statement": insight.get("problem_statement", ""),
            "proposed_solution": insight.get("proposed_solution", ""),
            "market_size_estimate": insight.get("market_size_estimate", ""),
            "relevance_score": insight.get("relevance_score", ""),
            "opportunity_score": insight.get("opportunity_score", ""),
            "problem_score": insight.get("problem_score", ""),
            "feasibility_score": insight.get("feasibility_score", ""),
            "why_now_score": insight.get("why_now_score", ""),
            "revenue_potential": insight.get("revenue_potential", ""),
            "execution_difficulty": insight.get("execution_difficulty", ""),
            "go_to_market_score": insight.get("go_to_market_score", ""),
            "founder_fit_score": insight.get("founder_fit_score", ""),
            "source": insight.get("raw_signal", {}).get("source", ""),
            "created_at": insight.get("created_at", ""),
        }
        writer.writerow(row)

    return output.getvalue()


# ============================================================
# Research Analysis Export Functions
# ============================================================


def export_analysis_pdf(analysis: dict[str, Any]) -> str:
    """
    Generate PDF HTML content for a research analysis.

    Args:
        analysis: Research analysis data dictionary

    Returns:
        str: HTML content for PDF conversion
    """
    sections = [
        {
            "heading": "Idea Overview",
            "content": {
                "Description": analysis.get("idea_description", "N/A"),
                "Target Market": analysis.get("target_market", "N/A"),
                "Budget Range": analysis.get("budget_range", "N/A"),
            },
        },
    ]

    # Market Analysis
    market = analysis.get("market_analysis", {})
    if market:
        sections.append({
            "heading": "Market Analysis",
            "content": {
                "TAM": market.get("tam", "N/A"),
                "SAM": market.get("sam", "N/A"),
                "SOM": market.get("som", "N/A"),
                "Growth Rate": f"{market.get('growth_rate', 0) * 100:.1f}%",
                "Maturity": market.get("market_maturity", "N/A"),
                "Key Trends": ", ".join(market.get("key_trends", [])),
            },
        })

    # Value Equation
    value = analysis.get("value_equation", {})
    if value:
        sections.append({
            "heading": "Value Equation (Hormozi Framework)",
            "content": {
                "Dream Outcome": f"{value.get('dream_outcome_score', 0)}/10",
                "Perceived Likelihood": f"{value.get('perceived_likelihood_score', 0)}/10",
                "Time Delay": f"{value.get('time_delay_score', 0)}/10",
                "Effort/Sacrifice": f"{value.get('effort_sacrifice_score', 0)}/10",
                "Value Score": f"{value.get('value_score', 0):.2f}",
                "Analysis": value.get("analysis", "N/A"),
            },
        })

    # Competitor Landscape
    competitors = analysis.get("competitor_landscape", [])
    if competitors:
        competitor_list = [
            f"â€¢ {c.get('name', 'Unknown')}: {c.get('unique_value_prop', 'N/A')} "
            f"(Threat: {c.get('threat_level', 'N/A')})"
            for c in competitors[:5]
        ]
        sections.append({
            "heading": "Competitor Landscape",
            "content": competitor_list,
        })

    # Execution Roadmap
    roadmap = analysis.get("execution_roadmap", [])
    if roadmap:
        phases = [
            f"Phase {p.get('phase_number', 0)}: {p.get('name', 'N/A')} - {p.get('duration', 'N/A')}"
            for p in roadmap
        ]
        sections.append({
            "heading": "Execution Roadmap",
            "content": phases,
        })

    # Risk Assessment
    risk = analysis.get("risk_assessment", {})
    if risk:
        sections.append({
            "heading": "Risk Assessment",
            "content": {
                "Technical Risk": f"{risk.get('technical_risk', 0)}/10",
                "Market Risk": f"{risk.get('market_risk', 0)}/10",
                "Team Risk": f"{risk.get('team_risk', 0)}/10",
                "Financial Risk": f"{risk.get('financial_risk', 0)}/10",
                "Overall Risk": f"{risk.get('overall_risk', 0) * 100:.0f}%",
            },
        })

    # Summary Scores
    sections.append({
        "heading": "Summary Scores",
        "content": {
            "Opportunity Score": f"{analysis.get('opportunity_score', 0) * 100:.0f}%",
            "Market Fit Score": f"{analysis.get('market_fit_score', 0) * 100:.0f}%",
            "Execution Readiness": f"{analysis.get('execution_readiness', 0) * 100:.0f}%",
        },
    })

    return generate_pdf_content(
        title="Research Analysis Report",
        sections=sections,
        metadata={
            "generated_at": datetime.now().strftime("%Y-%m-%d %H:%M"),
            "analysis_id": analysis.get("id", "N/A"),
            "status": analysis.get("status", "N/A"),
        },
    )


def export_analysis_csv(analyses: list[dict[str, Any]]) -> str:
    """
    Generate CSV content for multiple research analyses.

    Args:
        analyses: List of analysis dictionaries

    Returns:
        str: CSV content as string
    """
    output = io.StringIO()

    fieldnames = [
        "id",
        "idea_description",
        "target_market",
        "budget_range",
        "status",
        "opportunity_score",
        "market_fit_score",
        "execution_readiness",
        "tam",
        "sam",
        "som",
        "overall_risk",
        "created_at",
    ]

    writer = csv.DictWriter(output, fieldnames=fieldnames, extrasaction="ignore")
    writer.writeheader()

    for analysis in analyses:
        market = analysis.get("market_analysis", {}) or {}
        risk = analysis.get("risk_assessment", {}) or {}

        row = {
            "id": str(analysis.get("id", "")),
            "idea_description": analysis.get("idea_description", "")[:200],
            "target_market": analysis.get("target_market", ""),
            "budget_range": analysis.get("budget_range", ""),
            "status": analysis.get("status", ""),
            "opportunity_score": analysis.get("opportunity_score", ""),
            "market_fit_score": analysis.get("market_fit_score", ""),
            "execution_readiness": analysis.get("execution_readiness", ""),
            "tam": market.get("tam", ""),
            "sam": market.get("sam", ""),
            "som": market.get("som", ""),
            "overall_risk": risk.get("overall_risk", ""),
            "created_at": analysis.get("created_at", ""),
        }
        writer.writerow(row)

    return output.getvalue()


def export_analysis_json(analysis: dict[str, Any]) -> str:
    """
    Generate pretty-printed JSON for a research analysis.

    Args:
        analysis: Research analysis data dictionary

    Returns:
        str: Pretty-printed JSON string
    """
    # Create clean export structure
    export_data = {
        "meta": {
            "exported_at": datetime.now().isoformat(),
            "format_version": "1.0",
            "source": "StartInsight Research Agent",
        },
        "analysis": analysis,
    }

    return json.dumps(export_data, indent=2, default=str)


# ============================================================
# Export Response Generator
# ============================================================


def get_export_response(
    content: str,
    format: ExportFormat,
    filename: str,
) -> dict[str, Any]:
    """
    Generate export response with appropriate content type and headers.

    Args:
        content: Export content (HTML for PDF, CSV string, JSON string)
        format: Export format enum
        filename: Base filename (without extension)

    Returns:
        dict: Response metadata including content, content_type, filename
    """
    content_types = {
        ExportFormat.PDF: "text/html",  # HTML that can be converted to PDF
        ExportFormat.CSV: "text/csv",
        ExportFormat.JSON: "application/json",
    }

    extensions = {
        ExportFormat.PDF: "html",  # Return as HTML for client-side PDF generation
        ExportFormat.CSV: "csv",
        ExportFormat.JSON: "json",
    }

    return {
        "content": content,
        "content_type": content_types[format],
        "filename": f"{filename}.{extensions[format]}",
        "format": format.value,
    }
